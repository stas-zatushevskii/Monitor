package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

const (
	tagMarker     = "generate:reset"
	genFilename   = "reset.gen.go"
	headerComment = "// Code generated by cmd/reset; DO NOT EDIT.\n"
)

func main() {
	if err := run(); err != nil {
		fmt.Fprintln(os.Stderr, "reset generator error:", err)
		os.Exit(1)
	}
}

func run() error {
	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedFiles |
			packages.NeedSyntax |
			packages.NeedTypes |
			packages.NeedTypesInfo,
		Dir: ".",
	}

	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		return err
	}
	if packages.PrintErrors(pkgs) > 0 {
		return fmt.Errorf("packages load failed")
	}

	for _, pkg := range pkgs {
		gen, err := generateForPackage(pkg)
		if err != nil {
			return fmt.Errorf("package %s: %w", pkg.PkgPath, err)
		}
		if gen == "" {
			continue
		}
		if len(pkg.GoFiles) == 0 {
			continue
		}
		dir := filepath.Dir(pkg.GoFiles[0])
		outPath := filepath.Join(dir, genFilename)
		if err := os.WriteFile(outPath, []byte(gen), 0o644); err != nil {
			return fmt.Errorf("write %s: %w", outPath, err)
		}
	}
	return nil
}

type targetStruct struct {
	name   string
	fields []structField
}

type structField struct {
	name string
	typ  types.Type
	tag  string
	pos  token.Pos
}

func generateForPackage(pkg *packages.Package) (string, error) {
	targets, err := findTaggedStructs(pkg)
	if err != nil {
		return "", err
	}
	if len(targets) == 0 {
		return "", nil
	}

	var buf bytes.Buffer
	buf.WriteString(headerComment)
	buf.WriteString("package " + pkg.Name + "\n\n")

	for _, ts := range targets {
		buf.WriteString(genResetMethod(ts))
		buf.WriteByte('\n')
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.String(), nil
	}
	return string(src), nil
}

func findTaggedStructs(pkg *packages.Package) ([]targetStruct, error) {
	var out []targetStruct

	tagged := map[string]bool{}

	for _, f := range pkg.Syntax {
		for _, decl := range f.Decls {
			gd, ok := decl.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}
			groupTagged := gd.Doc != nil && strings.Contains(gd.Doc.Text(), tagMarker)
			for _, sp := range gd.Specs {
				ts, ok := sp.(*ast.TypeSpec)
				if !ok {
					continue
				}
				specTagged := (ts.Doc != nil && strings.Contains(ts.Doc.Text(), tagMarker)) || groupTagged
				if !specTagged {
					continue
				}
				if _, ok := ts.Type.(*ast.StructType); ok {
					tagged[ts.Name.Name] = true
				}
			}
		}
	}

	if len(tagged) == 0 {
		return nil, nil
	}

	scope := pkg.Types.Scope()
	for name := range tagged {
		obj := scope.Lookup(name)
		tn, ok := obj.(*types.TypeName)
		if !ok {
			continue
		}
		st, ok := tn.Type().Underlying().(*types.Struct)
		if !ok {
			continue
		}
		ts := targetStruct{name: name}
		for i := 0; i < st.NumFields(); i++ {
			v := st.Field(i)
			ts.fields = append(ts.fields, structField{
				name: v.Name(),
				typ:  v.Type(),
				tag:  st.Tag(i),
			})
		}
		out = append(out, ts)
	}
	return out, nil
}

func genResetMethod(ts targetStruct) string {
	var b bytes.Buffer
	recv := strings.ToLower(ts.name[:1])
	fmt.Fprintf(&b, "func (%s *%s) Reset() {\n", recv, ts.name)
	fmt.Fprintf(&b, "    if %s == nil { return }\n", recv)

	for _, f := range ts.fields {
		fieldExpr := fmt.Sprintf("%s.%s", recv, f.name)
		b.WriteString(genResetForType(fieldExpr, f.typ))
	}

	b.WriteString("}\n")
	return b.String()
}

func genResetForType(lhs string, t types.Type) string {
	switch tt := t.(type) {
	case *types.Basic:
		return fmt.Sprintf("    %s = %s\n", lhs, zeroForBasic(tt))
	case *types.Slice:
		return fmt.Sprintf("    %s = %s[:0]\n", lhs, lhs)
	case *types.Map:
		return fmt.Sprintf("    clear(%s)\n", lhs)
	case *types.Pointer:
		inner := tt.Elem()
		var sb strings.Builder
		fmt.Fprintf(&sb, "    if %s != nil {\n", lhs)
		switch it := inner.(type) {
		case *types.Basic:
			fmt.Fprintf(&sb, "        *%s = %s\n", lhs, zeroForBasic(it))
		case *types.Slice:
			fmt.Fprintf(&sb, "        *%s = (*%s)[:0]\n", lhs, lhs)
		case *types.Map:
			fmt.Fprintf(&sb, "        clear(*%s)\n", lhs)
		default:
			fmt.Fprintf(&sb, "        if resetter, ok := any(%s).(interface{ Reset() }); ok {\n", lhs)
			fmt.Fprintf(&sb, "            resetter.Reset()\n")
			fmt.Fprintf(&sb, "        }\n")
		}
		sb.WriteString("    }\n")
		return sb.String()
	case *types.Struct:
		var sb strings.Builder
		fmt.Fprintf(&sb, "    if resetter, ok := any(&%s).(interface{ Reset() }); ok {\n", lhs)
		fmt.Fprintf(&sb, "        resetter.Reset()\n")
		fmt.Fprintf(&sb, "    }\n")
		return sb.String()
	default:
		return ""
	}
}

func zeroForBasic(b *types.Basic) string {
	switch b.Kind() {
	case types.UntypedBool, types.Bool:
		return "false"
	case types.UntypedString, types.String:
		return `""`
	case types.UntypedRune, types.Rune, types.Byte, types.Int, types.Int8, types.Int16, types.Int32, types.Int64,
		types.Uint, types.Uint8, types.Uint16, types.Uint32, types.Uint64, types.Uintptr:
		return "0"
	case types.Float32, types.Float64, types.UntypedFloat:
		return "0"
	case types.Complex64, types.Complex128, types.UntypedComplex:
		return "0"
	default:
		return "0"
	}
}
